{"ast":null,"code":"function checkCol(grid, colIdx, val) {\n  const col = Array(9).fill(0);\n\n  for (let i = 0; i < 9; i++) col[i] = grid[i][colIdx];\n\n  return !col.includes(val);\n}\n\nfunction checkRow(grid, rowIdx, val) {\n  return !grid[rowIdx].includes(val);\n}\n\nfunction checkSquare(grid, rowIdx, colIdx, val) {\n  let startR = Math.floor(rowIdx / 3);\n  let startC = Math.floor(colIdx / 3);\n\n  for (let i = 0; i < 2; i++) for (let j = 0; j < 2; j++) {\n    if (grid[startR + i][startC + j] === val) return false;\n  }\n\n  return true;\n}\n\nfunction backtrackNewGrid(grid, index) {\n  if (index === 81) return true; //console.log(index)\n\n  const vals = Array(9).fill(0); //console.log(\"back tracking\")\n\n  for (let i = 0; i < 9; i++) {\n    vals[i] = i + 1; //console.log(vals[i])\n  }\n\n  let row = Math.floor(index / 9);\n  let col = index % 9;\n\n  for (let i = 0; i < vals.length; i++) {\n    if (row === 0) console.log(\"inside\" + vals[i]);\n\n    if (checkCol(grid, row, vals[i]) && checkRow(grid, col, vals[i]) && checkSquare(grid, row, col, vals[i])) {\n      grid[row][col] = vals[i];\n      if (backtrackNewGrid(grid, index + 1)) return true;\n    }\n  }\n\n  return false;\n}\n\nfunction createNewGrid() {\n  const grid = [...Array(9)].map(() => [...Array(9).fill(0)]);\n  backtrackNewGrid(grid, 0);\n  return grid;\n}\n\nexport default createNewGrid;","map":{"version":3,"sources":["C:/Users/aritrasen/Documents/react_projects/soduku/src/utils/createNewGrid.js"],"names":["checkCol","grid","colIdx","val","col","Array","fill","i","includes","checkRow","rowIdx","checkSquare","startR","Math","floor","startC","j","backtrackNewGrid","index","vals","row","length","console","log","createNewGrid","map"],"mappings":"AAAA,SAASA,QAAT,CAAkBC,IAAlB,EAAuBC,MAAvB,EAA8BC,GAA9B,EACA;AACK,QAAMC,GAAG,GAAGC,KAAK,CAAC,CAAD,CAAL,CAASC,IAAT,CAAc,CAAd,CAAZ;;AACA,OAAI,IAAIC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,CAAf,EAAiBA,CAAC,EAAlB,EACEH,GAAG,CAACG,CAAD,CAAH,GAASN,IAAI,CAACM,CAAD,CAAJ,CAAQL,MAAR,CAAT;;AACF,SAAO,CAACE,GAAG,CAACI,QAAJ,CAAaL,GAAb,CAAR;AACJ;;AAED,SAASM,QAAT,CAAkBR,IAAlB,EAAuBS,MAAvB,EAA8BP,GAA9B,EACA;AACK,SAAO,CAACF,IAAI,CAACS,MAAD,CAAJ,CAAaF,QAAb,CAAsBL,GAAtB,CAAR;AACJ;;AAED,SAASQ,WAAT,CAAqBV,IAArB,EAA0BS,MAA1B,EAAiCR,MAAjC,EAAwCC,GAAxC,EACA;AACO,MAAIS,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWJ,MAAM,GAAC,CAAlB,CAAb;AACA,MAAIK,MAAM,GAAEF,IAAI,CAACC,KAAL,CAAWZ,MAAM,GAAC,CAAlB,CAAZ;;AACA,OAAI,IAAIK,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,CAAf,EAAkBA,CAAC,EAAnB,EACA,KAAI,IAAIS,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,CAAf,EAAkBA,CAAC,EAAnB,EACA;AACK,QAAGf,IAAI,CAACW,MAAM,GAACL,CAAR,CAAJ,CAAeQ,MAAM,GAACC,CAAtB,MAA2Bb,GAA9B,EACE,OAAO,KAAP;AACN;;AAED,SAAO,IAAP;AACN;;AAED,SAASc,gBAAT,CAA0BhB,IAA1B,EAAgCiB,KAAhC,EACA;AAAK,MAAGA,KAAK,KAAG,EAAX,EACG,OAAO,IAAP,CADR,CAEK;;AACA,QAAMC,IAAI,GAAGd,KAAK,CAAC,CAAD,CAAL,CAASC,IAAT,CAAc,CAAd,CAAb,CAHL,CAIK;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAE,CAAnB,EAAsBA,CAAC,EAAvB,EAA2B;AACrBY,IAAAA,IAAI,CAACZ,CAAD,CAAJ,GAASA,CAAC,GAAC,CAAX,CADqB,CAErB;AACF;;AACJ,MAAIa,GAAG,GAAGP,IAAI,CAACC,KAAL,CAAWI,KAAK,GAAC,CAAjB,CAAV;AACA,MAAId,GAAG,GAAGc,KAAK,GAAC,CAAhB;;AACA,OAAI,IAAIX,CAAC,GAAC,CAAV,EAAaA,CAAC,GAACY,IAAI,CAACE,MAApB,EAA4Bd,CAAC,EAA7B,EACA;AAEI,QAAGa,GAAG,KAAG,CAAT,EACEE,OAAO,CAACC,GAAR,CAAY,WAASJ,IAAI,CAACZ,CAAD,CAAzB;;AAED,QAAGP,QAAQ,CAACC,IAAD,EAAMmB,GAAN,EAAUD,IAAI,CAACZ,CAAD,CAAd,CAAR,IAA4BE,QAAQ,CAACR,IAAD,EAAMG,GAAN,EAAUe,IAAI,CAACZ,CAAD,CAAd,CAApC,IAAwDI,WAAW,CAACV,IAAD,EAAMmB,GAAN,EAAUhB,GAAV,EAAce,IAAI,CAACZ,CAAD,CAAlB,CAAtE,EACA;AACAN,MAAAA,IAAI,CAACmB,GAAD,CAAJ,CAAUhB,GAAV,IAAiBe,IAAI,CAACZ,CAAD,CAArB;AACA,UAAGU,gBAAgB,CAAChB,IAAD,EAAMiB,KAAK,GAAC,CAAZ,CAAnB,EACK,OAAO,IAAP;AACJ;AACL;;AACF,SAAO,KAAP;AACH;;AAED,SAASM,aAAT,GACA;AACK,QAAMvB,IAAI,GAAI,CAAC,GAAGI,KAAK,CAAC,CAAD,CAAT,EAAcoB,GAAd,CAAmB,MAAK,CAAC,GAAGpB,KAAK,CAAC,CAAD,CAAL,CAASC,IAAT,CAAc,CAAd,CAAJ,CAAxB,CAAd;AACAW,EAAAA,gBAAgB,CAAChB,IAAD,EAAM,CAAN,CAAhB;AACA,SAAOA,IAAP;AAEJ;;AAED,eAAeuB,aAAf","sourcesContent":["function checkCol(grid,colIdx,val)\r\n{\r\n     const col = Array(9).fill(0)\r\n     for(let i=0; i<9;i++)\r\n       col[i] = grid[i][colIdx]\r\n     return !col.includes(val) \r\n}\r\n\r\nfunction checkRow(grid,rowIdx,val)\r\n{\r\n     return !grid[rowIdx].includes(val)\r\n}\r\n\r\nfunction checkSquare(grid,rowIdx,colIdx,val)\r\n{\r\n       let startR = Math.floor(rowIdx/3)\r\n       let startC= Math.floor(colIdx/3)\r\n       for(let i=0; i<2; i++)\r\n       for(let j=0; j<2; j++)\r\n       {\r\n            if(grid[startR+i][startC+j]===val)\r\n              return false\r\n       }\r\n\r\n       return true\r\n}\r\n\r\nfunction backtrackNewGrid(grid, index)\r\n{    if(index===81)\r\n        return true;\r\n     //console.log(index)\r\n     const vals = Array(9).fill(0)\r\n     //console.log(\"back tracking\")\r\n     for (let i = 0; i <9; i++) {\r\n           vals[i]= i+1\r\n           //console.log(vals[i])\r\n        }\r\n     let row = Math.floor(index/9)\r\n     let col = index%9  \r\n     for(let i=0; i<vals.length; i++)\r\n     {\r\n         \r\n         if(row===0)\r\n           console.log(\"inside\"+vals[i])\r\n\r\n          if(checkCol(grid,row,vals[i])&&checkRow(grid,col,vals[i])&&checkSquare(grid,row,col,vals[i]))\r\n          {\r\n          grid[row][col] = vals[i]\r\n          if(backtrackNewGrid(grid,index+1))\r\n               return true\r\n          }     \r\n     }\r\n    return false\r\n}\r\n\r\nfunction createNewGrid()\r\n{\r\n     const grid =  [...Array(9)].map( ()=> [...Array(9).fill(0)])\r\n     backtrackNewGrid(grid,0)\r\n     return grid\r\n\r\n}\r\n\r\nexport default createNewGrid;"]},"metadata":{},"sourceType":"module"}